import datetime
import enum
import logging
import uuid
from urllib.parse import parse_qs

import github
import lib
import requests
from django.conf import settings
from django.contrib.auth import get_user_model
from django.db import models
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.utils import timezone

logger = logging.getLogger(__name__)


class Token(models.Model):
    """
    This model takes care of the tokens generated by the Github applications.
    """

    token = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField()

    class Meta:
        abstract = True


class GithubUser(models.Model):
    user = models.OneToOneField(
        get_user_model(), on_delete=models.CASCADE, related_name="github_user"
    )
    account_name = models.CharField(max_length=200)
    account_id = models.BigIntegerField()
    account_type = models.CharField(max_length=20)
    avatar_url = models.CharField(max_length=200)
    created_at = models.DateTimeField(auto_now_add=True)

    @property
    def access_token(self):
        try:
            return (
                self.access_tokens.exclude(expires_at__lt=timezone.now())
                .latest("expires_at")
                .token
            )
        except:
            return None

    @property
    def refresh_token(self):
        try:
            return (
                self.refresh_tokens.exclude(expires_at__lt=timezone.now())
                .latest("expires_at")
                .token
            )
        except:
            return None

    def process_token_response(self, token_response):
        now = timezone.now()
        logger.info(token_response)
        data = parse_qs(token_response)
        GithubUserAccessToken.objects.create(
            token=data["access_token"][0],
            github_user=self,
            expires_at=now + datetime.timedelta(seconds=int(data["expires_in"][0])),
        )
        GithubUserRefreshToken.objects.create(
            token=data["refresh_token"][0],
            github_user=self,
            expires_at=now
            + datetime.timedelta(seconds=int(data["refresh_token_expires_in"][0])),
        )

    def get_new_tokens(self):
        refresh_token = self.refresh_tokens.exclude(
            expires_at__lt=timezone.now()
        ).latest("expires_at")
        response = requests.post(
            "https://github.com/login/oauth/access_token",
            data={
                "refresh_token": refresh_token.token,
                "grant_type": "refresh_token",
                "client_id": settings.GITHUB_CREDS["client_id"],
                "client_secret": settings.GITHUB_CREDS["client_secret"],
            },
        )
        self.process_token_response(response.content.decode())


class GithubUserAccessToken(Token):
    github_user = models.ForeignKey(
        GithubUser, on_delete=models.CASCADE, related_name="access_tokens"
    )


class GithubUserRefreshToken(Token):
    github_user = models.ForeignKey(
        GithubUser, on_delete=models.CASCADE, related_name="refresh_tokens"
    )


class GithubAppInstallation(models.Model):
    """
    This model takes care of the Github installations.
    """

    class InstallationState(models.TextChoices):
        INSTALLED = "INSTALLED", "Installed"
        UNINSTALLED = "UNINSTALLED", "Uninstalled"

    installation_id = models.BigIntegerField(unique=True, db_index=True)
    creator = models.ForeignKey(GithubUser, on_delete=models.PROTECT)
    state = models.CharField(max_length=20, choices=InstallationState.choices)
    account_name = models.CharField(max_length=200)
    account_id = models.BigIntegerField()
    account_type = models.CharField(max_length=20)
    avatar_url = models.CharField(max_length=200)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self) -> str:
        return f"{self.account_name}[{self.installation_id}] Owner: {self.creator.account_name}"

    @property
    def access_token(self):
        try:
            return (
                self.tokens.exclude(expires_at__lte=timezone.now())
                .latest("created_at")
                .token
            )
        except GithubInstallationToken.DoesNotExist:
            self.update_token()
            return self.get_latest_active_token()

    def update_token(self):
        """
        Fetches the latest access token for the installation. Returns true/false depending on whether
        the requested token has been updated
        """
        # User token not required for this step
        github_installation_manager = lib.GithubInstallationManager(
            installation_id=self.installation_id, user_token=""
        )
        token, expires_at = github_installation_manager.get_installation_access_token()
        return GithubInstallationToken.objects.get_or_create(
            token=token,
            expires_at=expires_at,
            github_app_installation=self,
        )[1]


class GithubInstallationToken(Token):
    github_app_installation = models.ForeignKey(
        GithubAppInstallation, on_delete=models.CASCADE, related_name="tokens"
    )


class GithubRepository(models.Model):
    repo_id = models.BigIntegerField()
    repo_name = models.CharField(max_length=150)
    repo_full_name = models.CharField(max_length=200, unique=True)
    owner = models.ForeignKey(GithubAppInstallation, on_delete=models.PROTECT)

    def __str__(self) -> str:
        return self.repo_full_name


class GithubRepoMap(models.Model):
    class IntegrationType(models.TextChoices):
        """
        FULL integration restricts the PRs to process only after the related PR is merged
        PARTIAL check is not restrictive
        """

        FULL = "FULL", "Full"
        PARTIAL = "PARTIAL", "Partial"

    integration = models.ForeignKey(GithubAppInstallation, on_delete=models.PROTECT)
    code_repo = models.ForeignKey(
        GithubRepository, on_delete=models.PROTECT, related_name="code_repos"
    )
    documentation_repo = models.ForeignKey(
        GithubRepository, on_delete=models.PROTECT, related_name="documentation_repos"
    )
    integration_type = models.CharField(max_length=20, choices=IntegrationType.choices)


@receiver(
    post_save, sender=GithubRepoMap, dispatch_uid="invoke_actions_on_repo_map_save"
)
def pull_request_post_save(sender, instance, **kwargs):
    # TODO: Sync all open PRs for the documentation repository and the code repository
    pass


class GithubPullRequest(models.Model):
    pr_id = models.BigIntegerField()
    pr_number = models.BigIntegerField()
    pr_head_commit_sha = models.CharField(max_length=40)
    pr_head_tree_sha = models.CharField(max_length=40)
    pr_head_modified_on = models.DateTimeField()
    pr_head_commit_message = models.CharField(max_length=200)
    updated_on = models.DateTimeField(auto_now=True)
    repository = models.ForeignKey(GithubRepository, on_delete=models.PROTECT)

    def __str__(self) -> str:
        return f"{self.repository.repo_full_name}/{self.pr_number} @ {self.pr_head_commit_sha[:7]}"


@receiver(
    post_save, sender=GithubPullRequest, dispatch_uid="invoke_actions_on_pr_update"
)
def pull_request_post_save(sender, instance, **kwargs):
    for documentation_pr in MonitoredPullRequest.objects.filter(
        documentation_pull_request=instance
    ).iterator():
        if (
            documentation_pr.pull_request_status
            == MonitoredPullRequest.PullRequestStatus.APPROVED
        ):
            documentation_pr.pull_request_status = (
                MonitoredPullRequest.PullRequestStatus.STALE_CODE
            )
        documentation_pr.save()
    for code_pr in MonitoredPullRequest.objects.filter(
        code_pull_request=instance
    ).iterator():
        if (
            code_pr.pull_request_status
            == MonitoredPullRequest.PullRequestStatus.APPROVED
        ):
            code_pr.pull_request_status = (
                MonitoredPullRequest.PullRequestStatus.STALE_APPROVAL
            )
        code_pr.save()


class MonitoredPullRequest(models.Model):
    class PullRequestStatus(models.TextChoices):
        """
        NOT_CONNECTED: Documentation PR Not connected
        APPROVAL_PENDING: PR Document is connected but the documentation is approved
        STALE_CODE: Documentation is connected but the Documentation has updated since the last commit
        STALE_APPROVAL: Approved in the past but the code has diverged since then
        APPROVED: Approved and the documentation is up to date
        """

        NOT_CONNECTED = "NOT_CONNECTED", "Not Connected"
        APPROVAL_PENDING = "APPROVAL_PENDING", "Approval Pending"
        STALE_CODE = "STALE_CODE", "Stale Code"
        STALE_APPROVAL = "STALE_APPROVAL", "Stale Approval"
        APPROVED = "APPROVED", "Approved"

    code_pull_request = models.ForeignKey(
        GithubPullRequest,
        on_delete=models.CASCADE,
        related_name="monitored_code",
        unique=True,
    )
    documentation_pull_request = models.ForeignKey(
        GithubPullRequest,
        on_delete=models.CASCADE,
        blank=True,
        null=True,
        related_name="monitored_documentation",
    )
    pull_request_status = models.CharField(
        max_length=20,
        choices=PullRequestStatus.choices,
        default=PullRequestStatus.NOT_CONNECTED,
    )

    def __str__(self) -> str:
        return f"{self.code_pull_request.repository.repo_full_name}[{self.code_pull_request.pr_number}]"

    def save(self, *args, **kwargs):
        if (
            self.documentation_pull_request is not None
            and self.pull_request_status
            == MonitoredPullRequest.PullRequestStatus.NOT_CONNECTED
        ):
            self.pull_request_status = (
                MonitoredPullRequest.PullRequestStatus.APPROVAL_PENDING
            )
        elif self.documentation_pull_request is None:
            self.pull_request_status = (
                MonitoredPullRequest.PullRequestStatus.NOT_CONNECTED
            )
        super().save(*args, **kwargs)


@receiver(
    post_save, sender=MonitoredPullRequest, dispatch_uid="invoke_github_check_for_pr"
)
def update_check_run(sender, instance, **kwargs):
    (instance, is_new) = GithubCheckRun.objects.get_or_create(
        ref_pull_request=instance, run_sha=instance.code_pull_request.pr_head_commit_sha
    )
    if is_new:
        # Here, we can close the previous checks if any
        # GithubCheckRun.objects.filter(ref_pull_request=instance).exclude(
        #     run_sha=instance.code_pull_request.pr_head_commit_sha,
        # )
        pass
    else:
        instance.save()


class GithubCheckRun(models.Model):
    run_id = models.BigIntegerField(blank=True, null=True)
    unique_id = models.UUIDField(default=uuid.uuid4)
    # Head of the request when it was run
    run_sha = models.CharField(max_length=40)
    ref_pull_request = models.ForeignKey(
        MonitoredPullRequest, on_delete=models.PROTECT, related_name="checks"
    )
    # This flag will be set to true if:
    # 1. The documentation_pr exists and pr has been approved(i.e. webhook for approval received)
    # 2. The documentation_pr does not exist and the user sets it manually
    force_approve = models.BooleanField(null=True, blank=True, default=None)

    class Meta:
        unique_together = (
            "run_sha",
            "ref_pull_request",
        )

    def save(self, *args, **kwargs):

        if not self.pk:
            # PK doesn't exist, new instance being saved to the DB. Create a new check
            token = (
                self.ref_pull_request.code_pull_request.repository.owner.creator.access_token
            )
            github_app_instance = github.Github(token)
            github_repo = github_app_instance.get_repo(
                self.ref_pull_request.code_pull_request.repository.repo_id
            )
            check_run_instance = github_repo.create_check_run(
                name="Continuous Documentation",
                head_sha=self.run_sha,
                external_id=self.unique_id.__str__(),
                status="in_progress",
                details_url=f"{settings.WEBSITE_HOST}/{github_repo.full_name}/pull/{self.ref_pull_request.code_pull_request.pr_number}",
            )
            logger.info(
                "Created new check run for PR", extra={"response": check_run_instance}
            )
            self.run_id = check_run_instance.id
        super().save(*args, **kwargs)


@receiver(post_save, sender=GithubCheckRun, dispatch_uid="update_github_check")
def synchronize_github_check(sender, instance, **kwargs):
    token = (
        instance.ref_pull_request.code_pull_request.repository.owner.creator.access_token
    )
    github_app_instance = github.Github(token)
    github_repo = github_app_instance.get_repo(
        instance.ref_pull_request.code_pull_request.repository.repo_id
    )
    check_run = github_repo.get_check_run(instance.run_id)

    data = {
        "name": "continuous documentation",
        "head_sha": instance.run_sha,
        "external_id": instance.unique_id.__str__(),
        "status": "completed",
        "conclusion": "action_required",
        "details_url": f"{settings.WEBSITE_HOST}/{github_repo.full_name}/pull/{instance.ref_pull_request.code_pull_request.pr_number}",
    }
    if (
        instance.ref_pull_request.pull_request_status
        == MonitoredPullRequest.PullRequestStatus.NOT_CONNECTED
    ):
        # Update the action with the PR connection action
        data.update(
            {
                "conclusion": "action_required",
                "output": {
                    "title": "Documentation PR is not connected",
                    "summary": "Please connect the documentation PR",
                    "text": "You can connect the documentation PR by clicking on the button below.",
                },
            }
        )
    elif (
        instance.ref_pull_request.pull_request_status
        == MonitoredPullRequest.PullRequestStatus.APPROVED
    ):
        data.update({"conclusion": "success"})
    elif instance.ref_pull_request.pull_request_status in [
        MonitoredPullRequest.PullRequestStatus.APPROVAL_PENDING,
        MonitoredPullRequest.PullRequestStatus.STALE_APPROVAL,
        MonitoredPullRequest.PullRequestStatus.STALE_CODE,
    ]:
        # Update the action with the PR approval action
        data.update(
            {
                "conclusion": "action_required",
                "output": {
                    "title": "Approve the PR on CDOC",
                    "summary": "Please approve the PR on CDOC",
                    "text": "You can connect the documentation PR by clicking on the button below.",
                },
            }
        )
    logger.info("Updating github check with data", extra={"payload": data})
    check_run_instance = check_run.edit(**data)
    logger.info("Updated the check run", extra={"response": check_run_instance})
