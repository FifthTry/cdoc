import datetime
import enum
import logging
import uuid
from urllib.parse import parse_qs

import github
import lib
import requests
from django.conf import settings
from django.contrib.auth import get_user_model
from django.db import models
from django.utils import timezone

logger = logging.getLogger(__name__)


class Token(models.Model):
    """
    This model takes care of the tokens generated by the Github applications.
    """

    token = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)
    expires_at = models.DateTimeField()

    class Meta:
        abstract = True


class GithubUser(models.Model):
    user = models.OneToOneField(
        get_user_model(), on_delete=models.CASCADE, related_name="github_user"
    )
    account_name = models.CharField(max_length=200)
    account_id = models.BigIntegerField()
    account_type = models.CharField(max_length=20)
    avatar_url = models.CharField(max_length=200)
    created_at = models.DateTimeField(auto_now_add=True)

    @property
    def access_token(self):
        try:
            return (
                self.access_tokens.exclude(expires_at__lt=timezone.now())
                .latest("expires_at")
                .token
            )
        except:
            return None

    def get_active_access_token(self):
        access_token = self.access_token
        if access_token is None:
            return self.get_new_tokens()[0]
        return access_token

    @property
    def refresh_token(self):
        try:
            return (
                self.refresh_tokens.exclude(expires_at__lt=timezone.now())
                .latest("expires_at")
                .token
            )
        except:
            return None

    def process_token_response(self, token_response):
        now = timezone.now()
        logger.info(token_response)
        data = parse_qs(token_response)
        access_token = GithubUserAccessToken.objects.create(
            token=data["access_token"][0],
            github_user=self,
            expires_at=now + datetime.timedelta(seconds=int(data["expires_in"][0])),
        )
        refresh_token = GithubUserRefreshToken.objects.create(
            token=data["refresh_token"][0],
            github_user=self,
            expires_at=now
            + datetime.timedelta(seconds=int(data["refresh_token_expires_in"][0])),
        )
        return (access_token.token, refresh_token.token)

    def get_new_tokens(self):
        refresh_token = self.refresh_tokens.exclude(
            expires_at__lt=timezone.now()
        ).latest("expires_at")
        response = requests.post(
            "https://github.com/login/oauth/access_token",
            data={
                "refresh_token": refresh_token.token,
                "grant_type": "refresh_token",
                "client_id": settings.GITHUB_CREDS["client_id"],
                "client_secret": settings.GITHUB_CREDS["client_secret"],
            },
        )
        return self.process_token_response(response.content.decode())


class GithubUserAccessToken(Token):
    github_user = models.ForeignKey(
        GithubUser, on_delete=models.CASCADE, related_name="access_tokens"
    )


class GithubUserRefreshToken(Token):
    github_user = models.ForeignKey(
        GithubUser, on_delete=models.CASCADE, related_name="refresh_tokens"
    )


class GithubAppInstallation(models.Model):
    """
    This model takes care of the Github installations.
    """

    class InstallationState(models.TextChoices):
        INSTALLED = "INSTALLED", "Installed"
        UNINSTALLED = "UNINSTALLED", "Uninstalled"

    installation_id = models.BigIntegerField(unique=True, db_index=True)
    creator = models.ForeignKey(GithubUser, on_delete=models.PROTECT)
    state = models.CharField(max_length=20, choices=InstallationState.choices)
    account_name = models.CharField(max_length=200)
    account_id = models.BigIntegerField()
    account_type = models.CharField(max_length=20)
    avatar_url = models.CharField(max_length=200)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self) -> str:
        return f"{self.account_name}[{self.installation_id}] Owner: {self.creator.account_name}"

    @property
    def access_token(self):
        try:
            return (
                self.tokens.exclude(expires_at__lte=timezone.now())
                .latest("created_at")
                .token
            )
        except GithubInstallationToken.DoesNotExist:
            self.update_token()
            return self.get_latest_active_token()

    def update_token(self):
        """
        Fetches the latest access token for the installation. Returns true/false depending on whether
        the requested token has been updated
        """
        # User token not required for this step
        github_installation_manager = lib.GithubInstallationManager(
            installation_id=self.installation_id, user_token=""
        )
        token, expires_at = github_installation_manager.get_installation_access_token()
        return GithubInstallationToken.objects.get_or_create(
            token=token,
            expires_at=expires_at,
            github_app_installation=self,
        )[1]


class GithubAppUser(models.Model):
    installation = models.ForeignKey(GithubAppInstallation, on_delete=models.CASCADE)
    github_user = models.ForeignKey(GithubUser, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ("installation", "github_user")

    def __str__(self) -> str:
        return f"{self.github_user.account_name}[{self.installation.installation_id}]"
        return super().__str__()


class GithubInstallationToken(Token):
    github_app_installation = models.ForeignKey(
        GithubAppInstallation, on_delete=models.CASCADE, related_name="tokens"
    )


class GithubRepository(models.Model):
    repo_id = models.BigIntegerField()
    repo_name = models.CharField(max_length=150)
    repo_full_name = models.CharField(max_length=200, unique=True)
    owner = models.ForeignKey(GithubAppInstallation, on_delete=models.PROTECT)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self) -> str:
        return self.repo_full_name


class GithubRepoMap(models.Model):
    class IntegrationType(models.TextChoices):
        """
        FULL integration restricts the PRs to process only after the related PR is merged
        PARTIAL check is not restrictive
        """

        FULL = "FULL", "Full"
        PARTIAL = "PARTIAL", "Partial"

    integration = models.ForeignKey(GithubAppInstallation, on_delete=models.PROTECT)
    code_repo = models.ForeignKey(
        GithubRepository, on_delete=models.PROTECT, related_name="code_repos"
    )
    documentation_repo = models.ForeignKey(
        GithubRepository, on_delete=models.PROTECT, related_name="documentation_repos"
    )
    integration_type = models.CharField(max_length=20, choices=IntegrationType.choices)
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ("integration", "code_repo", "documentation_repo")


class GithubPullRequest(models.Model):
    pr_id = models.BigIntegerField()
    pr_number = models.BigIntegerField()
    pr_head_commit_sha = models.CharField(max_length=40)
    pr_head_modified_on = models.DateTimeField(null=True, blank=True)
    pr_head_commit_message = models.CharField(max_length=200)
    pr_title = models.CharField(max_length=200)
    pr_body = models.TextField(default="", blank=True, null=True)
    pr_state = models.CharField(max_length=20)
    pr_created_at = models.DateTimeField(null=True, blank=True)
    pr_updated_at = models.DateTimeField(null=True, blank=True)
    pr_merged_at = models.DateTimeField(null=True, blank=True)
    pr_closed_at = models.DateTimeField(null=True, blank=True)
    pr_merged = models.BooleanField(default=False)
    pr_owner_username = models.CharField(max_length=100)
    updated_on = models.DateTimeField(auto_now=True)
    repository = models.ForeignKey(GithubRepository, on_delete=models.PROTECT)

    def __str__(self) -> str:
        return f"{self.repository.repo_full_name}/{self.pr_number} @ {self.pr_head_commit_sha[:7]}"

    def get_url(self):
        return (
            f"https://github.com/{self.repository.repo_full_name}/pull/{self.pr_number}"
        )


class MonitoredPullRequest(models.Model):
    class PullRequestStatus(models.TextChoices):
        """
        NOT_CONNECTED: Documentation PR Not connected
        APPROVAL_PENDING: PR Document is connected but the documentation is approved
        STALE_CODE: Documentation is connected but the Documentation has updated since the last commit
        STALE_APPROVAL: Approved in the past but the code has diverged since then
        APPROVED: Approved and the documentation is up to date
        """

        NOT_CONNECTED = "NOT_CONNECTED", "Not Connected"
        APPROVAL_PENDING = "APPROVAL_PENDING", "Approval Pending"
        STALE_CODE = "STALE_CODE", "Stale Code"
        STALE_APPROVAL = "STALE_APPROVAL", "Stale Approval"
        APPROVED = "APPROVED", "Approved"
        MANUAL_APPROVAL = "MANUALLY_APPROVED", "Manual Approval"

    code_pull_request = models.OneToOneField(
        GithubPullRequest,
        on_delete=models.CASCADE,
        related_name="monitored_code",
    )
    documentation_pull_request = models.ForeignKey(
        GithubPullRequest,
        on_delete=models.CASCADE,
        blank=True,
        null=True,
        related_name="monitored_documentation",
    )
    pull_request_status = models.CharField(
        max_length=20,
        choices=PullRequestStatus.choices,
        default=PullRequestStatus.NOT_CONNECTED,
    )
    integration = models.ForeignKey(GithubAppInstallation, on_delete=models.CASCADE)

    class Meta:
        unique_together = ("code_pull_request", "documentation_pull_request")

    def __str__(self) -> str:
        return f"{self.code_pull_request.repository.repo_full_name}[{self.code_pull_request.pr_number}]"

    def save(self, *args, **kwargs):
        if (
            self.documentation_pull_request is not None
            and self.pull_request_status
            == MonitoredPullRequest.PullRequestStatus.NOT_CONNECTED
        ):
            self.pull_request_status = (
                MonitoredPullRequest.PullRequestStatus.APPROVAL_PENDING
            )
        elif (
            self.documentation_pull_request is None
            and self.pull_request_status
            != MonitoredPullRequest.PullRequestStatus.MANUAL_APPROVAL
        ):
            self.pull_request_status = (
                MonitoredPullRequest.PullRequestStatus.NOT_CONNECTED
            )
        super().save(*args, **kwargs)

    def get_display_name(self):
        return f"{self.code_pull_request.repository.repo_full_name}/#{self.code_pull_request.pr_number}: {self.code_pull_request.pr_title}"


class GithubCheckRun(models.Model):
    run_id = models.BigIntegerField(blank=True, null=True)
    unique_id = models.UUIDField(default=uuid.uuid4)
    # Head of the request when it was run
    run_sha = models.CharField(max_length=40)
    ref_pull_request = models.ForeignKey(
        MonitoredPullRequest, on_delete=models.PROTECT, related_name="checks"
    )
    # This flag will be set to true if:
    # 1. The documentation_pr exists and pr has been approved(i.e. webhook for approval received)
    # 2. The documentation_pr does not exist and the user sets it manually
    force_approve = models.BooleanField(null=True, blank=True, default=None)

    class Meta:
        unique_together = (
            "run_sha",
            "ref_pull_request",
        )

    def __str__(self):
        return f"{self.ref_pull_request.code_pull_request.repository.repo_full_name}/{self.ref_pull_request.code_pull_request.pr_number} @ {self.run_sha[:7]} [{self.force_approve}]"

    def save(self, *args, **kwargs):

        if not self.pk:
            # PK doesn't exist, new instance being saved to the DB. Create a new check
            token = (
                self.ref_pull_request.code_pull_request.repository.owner.creator.access_token
            )
            github_app_instance = github.Github(token)
            github_repo = github_app_instance.get_repo(
                self.ref_pull_request.code_pull_request.repository.repo_id
            )
            check_run_instance = github_repo.create_check_run(
                name="Continuous Documentation",
                head_sha=self.run_sha,
                external_id=self.unique_id.__str__(),
                status="in_progress",
                details_url=f"{settings.WEBSITE_HOST}/{github_repo.full_name}/pull/{self.ref_pull_request.code_pull_request.pr_number}",
            )
            logger.info(
                "Created new check run for PR", extra={"response": check_run_instance}
            )
            self.run_id = check_run_instance.id
        super().save(*args, **kwargs)


class GithubLoginState(models.Model):
    """
    This model is used to store the state of the login process. Along with it,
    it also stores the redirect URL for the state.
    """

    state = models.UUIDField(default=uuid.uuid4)
    redirect_url = models.URLField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self) -> str:
        return self.state.__str__()
